<?php

declare(strict_types=1);

namespace Task\Task1BadMethod;

use mysqli;

class BadMethod
{
    /**
     * @deprecated DON'T USE THIS METHOD. IT IS BAD!
     *
     * Общая проблема кода в том что здесь смешаны все слои/уровни в одном месте. Хранение конфигурации,
     * инициализации подключения к БД, получение данных из внешнего запроса, формирование и выполнение SQL.
     * В реальном коде, скорей всего здесь же было бы применение этих данных (работа с HTML или JSON)
     *
     * @return array{id: string, name: string, phone: string, email: string, created: string}
     */
    public function badMethod(): array
    {
        /**
         * - Логин и пароль к базе данных задается в открытом виде. Это дает доступ всем желающим к БД. Необходимо
         *   получить секретные данные через конфигурацию/переменные окружения непосредственно на сервере.
         *
         * - Данные для доступа к БД прописаны непосредственно в коде. Это делает невозможным подмену окружения,
         *   например на тестовое, для запуска интеграционных тестов, а также заставляет использовать одни и теже
         *   данные для входа в БД на всех окружениях (прод, тест и тп)
         *
         * - Использования специфичного класса для доступа к БД. Есть PDO, который дает более высокую абстракцию для
         *   работы с базой.
         */
        $mysqli = new mysqli("127.0.0.1", "root", "1234", "testtask");
        /**
         * - Используется суперглобальный массив $_GET. Это плохая практика, потому что это делает зависимым результат
         *   от глобальных переменных которые можно поменять в любом месте и времени, что сильно усложняет поддержку
         *   данного кода. Также это усложняет процесс юнит тестирования, посколько перед запуском необходимо
         *   менять значения глобальных значений, а это может повлиять на другой код.
         *
         * - Нет проверки на то что данный ключ существует. При отсутсвии ключа, выдаст ошибку. Необходимо либо
         *   проверять наличие ключа методами isset, empty, array_key_exists или оператором ?? задавать значение по
         *   умолчанию.
         */
        $id = $_GET['id'];
        /**
         * - Возможность SQL инъекции. Необходимо проверять, фильтровать и приводить к нужному типу перед подстановкой
         *   в SQL выражение.
         */
        $res = $mysqli->query('SELECT * FROM users WHERE id='. $id);
        /**
         * - fetch_assoc возвращает данные без приведения типов. Например:
         *
         *   // var_dump($user);
         *
         *   array(5) {
         *     'id' => string(1) "1"
         *     'name' => string(6) "User 1"
         *     'phone' => string(11) "89830000101"
         *     'email' => string(17) "user1@example.com"
         *     'created' => string(19) "2023-01-12 16:33:25"
         *   }
         *
         *   При использовании строгой типизации это может дать ошибки некорректных типов, а также с такими данными
         *   неудобно работать в перспективе.
         */
        $user = $res->fetch_assoc();

        return $user;
    }
}